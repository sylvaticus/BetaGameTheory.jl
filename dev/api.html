<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · StrategicGames Documentation</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-DC4KL97F1C"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DC4KL97F1C', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">StrategicGames Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Index</a></li><li><a class="tocitem" href="using_other_languages.html">Using Python or R</a></li><li class="is-active"><a class="tocitem" href="api.html">API</a><ul class="internal"><li><a class="tocitem" href="#Detailed-API"><span>Detailed API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/StrategicGames.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Detailed-API"><a class="docs-heading-anchor" href="#Detailed-API">Detailed API</a><a id="Detailed-API-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.Verbosity" href="#StrategicGames.Verbosity"><code>StrategicGames.Verbosity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Verbosity</code></pre><p>Many functions accept a <code>verbosity</code> parameter.</p><p>Choose between: <code>NONE</code>, <code>LOW</code>, <code>STD</code> [default], <code>HIGH</code> and <code>FULL</code>.</p><p>Under default verbosity (<code>STD</code>) no output is printed, unless something unexpected in most conditions (but not necessarily an error) is detected </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.batch-Tuple{Integer, Integer}" href="#StrategicGames.batch-Tuple{Integer, Integer}"><code>StrategicGames.batch</code></a> — <span class="docstring-category">Method</span></header><section><div><p>batch(n,bsize;sequential=false,rng)</p><p>Return a vector of <code>bsize</code> vectors of indeces from <code>1</code> to <code>n</code>. Randomly unless the optional parameter <code>sequential</code> is used.</p><p><strong>Example:</strong></p><p><code>julia julia&gt; Utils.batch(6,2,sequential=true) 3-element Array{Array{Int64,1},1}:  [1, 2]  [3, 4]  [5, 6]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L141-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.best_response-Tuple{Any, Any, Any}" href="#StrategicGames.best_response-Tuple{Any, Any, Any}"><code>StrategicGames.best_response</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">best_response(payoff_array,strategy_profile,nplayer;solver)</code></pre><p>Return (possibly one of many) best strategy and corrsponding expected payoff for a given player.</p><p><strong>Parameters:</strong></p><ul><li><code>payoff_array</code>: the N_players+1 dimensional array of payoffs</li><li><code>strategy_profile</code>: the vector of vectors defining the strategies for the N players. The strategy for player n for which the best response is computed is used as initial values in the inner optimisation</li><li><code>nplayer</code>: counter of the player for which we want to compute the best_response (e.g. 1 or 3)</li><li><code>solver</code>: currently either &quot;GLPK&quot; or &quot;HiGHS&quot;</li><li><code>verbosity</code>: either <code>NONE</code>, <code>LOW</code>, <code>STD</code> [default], <code>HIGH</code> or <code>FULL</code></li></ul><p><strong>Returns:</strong></p><ul><li>A named tuple with: <code>expected_payoff</code>, <code>optimal_strategy</code>, <code>status</code> (of the underlying optimisation)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">julia&gt; using StrategicGames
julia&gt; payoff_array  = [(3,4) (1,5); (4,2) (2,3)] # prisoner&#39;s dilemma
2×2 Matrix{Tuple{Int64, Int64}}:
 (3, 4)  (1, 5)
 (4, 2)  (2, 3)
julia&gt; best_response(expand_dimensions(payoff_array),[[0.5,0.5],[0.5,0.5]],2)
(expected_payoff = 4.0, optimal_strategy = [0.0, 1.0], status = MathOptInterface.OPTIMAL)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L429-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.dominated_strategies-Tuple{Any}" href="#StrategicGames.dominated_strategies-Tuple{Any}"><code>StrategicGames.dominated_strategies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dominated_strategies(payoff;strict=true,iterated=true,dominated,support,verbosity)</code></pre><p>Implements the &quot;Iterated [by default] Removal of Strictly [by default] Dominated Strategies&quot; (IRSDS) algorithm, returning a vector (for each player) of vectors (action positions) of actions that for a given player are dominates by at least one of his other actions. This function is iterative (recursive) by default.</p><p><strong>Parameters</strong></p><ul><li><code>payoff_array</code>: the Nplayers+1 dimensional array of payoffs for the N players</li><li><code>strict</code>: wheter to look for strictly dominated actions [def: <code>true</code>]</li><li><code>iterated</code>: wheter to look for dominated actions iteractively [def: <code>true</code>]</li><li><code>dominated</code>: vector of vectors of actions to skip check as already deemed as dominated</li><li><code>support</code>: support profile to consider (vector of vectors, see notes). Default all actions</li><li><code>verbosity</code>: either <code>NONE</code>, <code>LOW</code>, <code>STD</code> [default], <code>HIGH</code> or <code>FULL</code></li></ul><p><strong>Notes</strong></p><ul><li>This function is available also as <code>dominated_strategies(payoff,player;strict)</code> returning a vector of dominated strategies for a given players (computed not iteractively)</li><li>Whae a particolar support is specified, the function looks for dominated strategies within the support for a given player, but considering also for possibly dominating actions outside its support. In both cases only the actions in the supports of the other players are considered.</li><li>To get the list of retrieved dominated actions at each iteration, use a verbosity level higher than <code>STD</code> </li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using StrategicGames
julia&gt; payoff = [(13,3) (1,4) (7,3); (4,1) (3,3) (6,2); (-1,9) (2,8) (8,-1)]
3×3 Matrix{Tuple{Int64, Int64}}:
 (13, 3)  (1, 4)  (7, 3)
 (4, 1)   (3, 3)  (6, 2)
 (-1, 9)  (2, 8)  (8, -1)
julia&gt; payoff_array = expand_dimensions(payoff);
julia&gt; dominated_player2 = dominated_strategies(payoff_array,2)
1-element Vector{Int64}:
 3
julia&gt; dominated = dominated_strategies(payoff_array,verbosity=HIGH)
Dominated strategies at step 1: [Int64[], [3]]
Dominated strategies at step 2: [[3], [3]]
Dominated strategies at step 3: [[3], [3, 1]]
Dominated strategies at step 4: [[3, 1], [3, 1]]
Dominated strategies at step 5: [[3, 1], [3, 1]]
2-element Vector{Vector{Int64}}:
 [3, 1]
 [3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L326-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.expand_dimensions-Union{Tuple{AbstractArray{T}}, Tuple{T}, Tuple{T2}} where {T2, T&lt;:Tuple{Vararg{T2}}}" href="#StrategicGames.expand_dimensions-Union{Tuple{AbstractArray{T}}, Tuple{T}, Tuple{T2}} where {T2, T&lt;:Tuple{Vararg{T2}}}"><code>StrategicGames.expand_dimensions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_dimensions(x::AbstractArray{T}</code></pre><p>Convenience function to transform a <em>N</em> dimensional array of tuples in a <em>N+1</em> dimensional array of scalars (the format used for most functions in this package).</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">julia&gt; using StrategicGames
julia&gt; payoff_tuple = [(1,-1) (-1,1) (1,0); (-1,1) (1, -1) (0,1)] # 2 players, with 2 and 3 actions respectively
2×3 Matrix{Tuple{Int64, Int64}}:
 (1, -1)  (-1, 1)  (1, 0)
 (-1, 1)  (1, -1)  (0, 1)

julia&gt; payoff_array = expand_dimensions(payoff_tuple)
2×3×2 Array{Int64, 3}:
[:, :, 1] =
  1  -1  1
 -1   1  0

[:, :, 2] =
 -1   1  0
  1  -1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L32-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.expected_value-Tuple{Any, Any}" href="#StrategicGames.expected_value-Tuple{Any, Any}"><code>StrategicGames.expected_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expected_value(v::Array{N,Real},p::Vector{Vector{Real}}) --&gt; Real</code></pre><p>Compute the expected value (scalar) of a N-dimensional value array given a vector of N probability vectors, one per each dimension of the value array. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.is_best_response-Tuple{Any, Any, Any}" href="#StrategicGames.is_best_response-Tuple{Any, Any, Any}"><code>StrategicGames.is_best_response</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_best_response(payoff_array,strategy_profile,nplayer;atol=1e-07,rtol=1e-07,solver,verbosity=STD)</code></pre><p>Determine if a given strategy for player <code>nplayer</code> is a best response to a given payoff array and strategies of the other players</p><p><strong>Parameters:</strong></p><ul><li><code>payoff_array</code>: the Nplayers+1 dimensional array of payoffs</li><li><code>strategy_profile</code>: the vector of vectors defining the strategies for the N players</li><li><code>nplayer</code>: counter of the player for which we want to verify if its strategy is a best_response (e.g. 1 or 3)</li><li><code>atol</code>: absolute tollerance in comparing the expected payoff from the given strategy and those from the optimal one [def: <code>1e-07</code>]</li><li><code>rtol</code>: relative tollerance in comparing the expected payoff from the given strategy and those from the optimal one [def: <code>1e-07</code>]</li><li><code>solver</code>: currently either &quot;GLPK&quot; or &quot;HiGHS&quot;</li><li><code>verbosity</code>: either <code>NONE</code>, <code>LOW</code>, <code>STD</code> [default], <code>HIGH</code> or <code>FULL</code></li></ul><p><strong>Example :</strong></p><pre><code class="language-julia hljs">julia&gt; using StrategicGames
julia&gt; payoff_array = [(3,4) (1,5); (4,2) (2,3)] # prisoner&#39;s dilemma
2×2 Matrix{Tuple{Int64, Int64}}:
 (3, 4)  (1, 5)
 (4, 2)  (2, 3)
julia&gt; is_best_response(expand_dimensions(payoff_array),[[0,1],[0.5,0.5]],1)
true
julia&gt; is_best_response(expand_dimensions(payoff_array),[[0,1],[0.5,0.5]],2)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L483-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.is_nash-Tuple{Any, Any}" href="#StrategicGames.is_nash-Tuple{Any, Any}"><code>StrategicGames.is_nash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_nash(payoff_array,strategy_profile;atol=1e-07,rtol=1e-07,solver,verbosity)</code></pre><p>Determine if a strategy profile is a Nash equilibrium for a given payoff array, i.e. if all strategies are (at least weak) best responses.</p><p><strong>Parameters:</strong></p><ul><li><code>payoff_array</code>: the Nplayers+1 array of payoffs</li><li><code>strategy_profile</code>: the vector of vectors defining the strategies for the N players</li><li><code>atol</code>: absolute tollerance in comparing the expected payoffs from the given strategies and those from the optimal ones [def: <code>1e-07</code>]</li><li><code>rtol</code>: relative tollerance in comparing the expected payoffs from the given strategies and those from the optimal ones [def: <code>1e-07</code>]</li><li><code>solver</code>: currently either &quot;GLPK&quot; or &quot;HiGHS&quot;</li><li><code>verbosity</code>: either <code>NONE</code>, <code>LOW</code>, <code>STD</code> [default], <code>HIGH</code> or <code>FULL</code></li></ul><p><strong>Example :</strong></p><pre><code class="language-julia hljs">julia&gt; using StrategicGames
julia&gt; payoff_array  = [(3,4) (1,5); (4,2) (2,3)] # prisoner&#39;s dilemma
2×2 Matrix{Tuple{Int64, Int64}}:
 (3, 4)  (1, 5)
 (4, 2)  (2, 3)
julia&gt; is_nash(expand_dimensions(payoff_array),[[0,1],[0,1]])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L516-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.nash_cp-Tuple{Any}" href="#StrategicGames.nash_cp-Tuple{Any}"><code>StrategicGames.nash_cp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nash_cp(payoff_array;init,verbosity)</code></pre><p>Find a Nash Equilibrium for N-players simultaneous games when mixed strategies are allowed using the Complementarity Problem formulation and implementing iterated removal of dominated strategies</p><p><strong>Parameters</strong></p><ul><li><code>payoff_array</code>: the Nplayers+1 dimensional array of payoffs for the N players</li><li><code>init</code>: a vector of vector of mixed strategies (i.e. PMFs) for each players to start the algorithm with. Different init points may reach different equilibrium points [def: equal probabilities for each available action of the players]</li><li><code>strict_domination_removal</code>: wether to remove only strictly dominated strategies in the pre-optimisation or also weakly dominated ones [def: <code>true</code>]</li><li><code>verbosity</code>: either <code>NONE</code>, <code>LOW</code>, <code>STD</code> [default], <code>HIGH</code> or <code>FULL</code></li></ul><p><strong>Notes</strong></p><ul><li>This function uses a complementarity formulation. For N &lt;= 2 the problem, except the complementarity equation, is linear and known as LCP (Linear Complementarity Problem)</li><li>This implementation uses the JuMP modelling language with the Ipopt solver engine (and hence it uses an interior point method instead of the pivotal approach used in the original Lemke-Howson [1964] algorithm)</li><li>There is no guarantee on timing and even that the algorithm converge to an equilibrium. Different Nash equilibriums may be reached by setting different initial points</li><li>By default the iterative removal of dominated strategies concerns only <em>strictly</em> dominated ones. For some games where the algorithm doesn&#39;t find a Nash equilibrium, you can often get success setting the algorithm to remove also weakly dominated strategies. </li></ul><p><strong>Returns</strong></p><ul><li>A named tuple with the following elements: <code>status</code>,<code>equilibrium_strategies</code>,<code>expected_payoffs</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using StrategicGames
julia&gt; payoff = [(-1,-1) (-3,0); (0, -3) (-2, -2)] # prisoner&#39;s dilemma
2×2 Matrix{Tuple{Int64, Int64}}:
 (-1, -1)  (-3, 0)
 (0, -3)   (-2, -2)
julia&gt; eq     = nash_cp(expand_dimensions(payoff));
julia&gt; eq_strategies = eq.equilibrium_strategies
2-element Vector{Vector{Float64}}:
 [-4.049752569180346e-11, 1.0000000000404976]
 [-4.0497525691839856e-11, 1.0000000000404976]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L207-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.nash_on_support" href="#StrategicGames.nash_on_support"><code>StrategicGames.nash_on_support</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nash_on_support(payoff_array,support;init,verbosity)</code></pre><p>Find (if it exists) a Nash equilibrium for N-players simultaneous games when mixed strategies are allowed on a specific support.</p><p><strong>Parameters</strong></p><ul><li><code>payoff_array</code>: the Nplayers+1 dimensional array of payoffs for the N players</li><li><code>support</code>: vector of vector of action counts that are in the tested support for each player [def: full support]</li><li><code>init</code>: a vector of vector of mixed strategies (i.e. PMFs) for each players to start the algorithm with. Different init points may reach different equilibrium points [def: equal probabilities for each available action of the players]</li><li><code>verbosity</code>: either <code>NONE</code>, <code>LOW</code>, <code>STD</code> [default], <code>HIGH</code> or <code>FULL</code></li></ul><p><strong>Notes</strong></p><ul><li>This implementation uses the JuMP modelling language with the Ipopt solver engine</li></ul><p><strong>Returns</strong></p><ul><li>A named tuple with the following elements: <code>status</code>,<code>equilibrium_strategies</code>,<code>expected_payoffs</code>, <code>solved</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using StrategicGames
julia&gt; payoff = [(-1,-1) (-3,0); (0, -3) (-2, -2)] # prisoner&#39;s dilemma. Only Nash eq is [[0,1],[0,1]]
2×2 Matrix{Tuple{Int64, Int64}}:
 (-1, -1)  (-3, 0)
 (0, -3)   (-2, -2)
julia&gt; payoff_array = expand_dimensions(payoff);
julia&gt; nash_on_support(payoff_array,[[1,2],[1,2]]).solved # false
false
julia&gt; nash_on_support(payoff_array,[[2],[2]]).solved     # true
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L546-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.nash_se-Tuple{Any}" href="#StrategicGames.nash_se-Tuple{Any}"><code>StrategicGames.nash_se</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nash_se(payoff_array; allow_mixed=true, max_samples=1, verbosity=STD)</code></pre><p>Compute <code>max_samples</code> (default one) Nash equilibria for a N-players generic game in normal form using support enumeration method.</p><p><strong>Parameters</strong></p><ul><li><code>payoff_array</code>: the Nplayers+1 dimensional array of payoffs for the N players</li><li><code>allow_mixed</code>: wether to look and report also mixed strategies (default) or look only for pure strategies (if any)</li><li><code>max_samples</code>: number of found sample Nash equilibria needed to stop the algorithm [def: <code>1</code>]. Set it to <code>Inf</code> to look for all the possible isolated equilibria of the game</li><li><code>mt</code>: wheter to use multithreads (def: <code>true</code>). Note that currently multithreading is always disable for a single eq search due to performance issues</li><li><code>verbosity</code>: either <code>NONE</code>, <code>LOW</code>, <code>STD</code> [default], <code>HIGH</code> or <code>FULL</code></li></ul><p><strong>Notes</strong></p><ul><li>This function uses a support enumeration method to avoid the complementarity conditions and solve simpler problems conditional to a specific support.  More specifically we use the heuristic of <a href="https://doi.org/10.1016/j.geb.2006.03.015">Porter-Nudelman-Shoham (2008)</a> and a dominance check, altought not recursively as in  <a href="https://web.archive.org/web/20230401080619/https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=36ba7977838df2bfdeab22157b0ed6ce940fb2be">Turocy (2007)</a></li><li>Given enought computational resources, all isolated Nash equilibria that are unique for a given support should be returned by this function </li></ul><p><strong>Returns</strong></p><ul><li>A vector of named tuples (even for the default single <code>max_samples</code>) with the following information: <code>equilibrium_strategies</code>, <code>expected_payoffs</code>, <code>supports</code> </li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using StrategicGames
julia&gt; payoff = expand_dimensions([(3,3) (3,2);
                                   (2,2) (5,6);
                                   (0,3) (6,1)]);
julia&gt; eqs = nash_se(payoff,max_samples=Inf)
3-element Vector{NamedTuple{(:equilibrium_strategies, :expected_payoffs, :supports), Tuple{Vector{Vector{Float64}}, Vector{Float64}, Vector{Vector{Int64}}}}}:
 (equilibrium_strategies = [[0.9999999999999999, 0.0, 0.0], [0.9999999999999999, 0.0]], expected_payoffs = [2.9999999999999516, 2.9999999999999516], supports = [[1], [1]])
 (equilibrium_strategies = [[0.8, 0.2, 0.0], [0.6666666666666666, 0.33333333333333337]], expected_payoffs = [3.0, 2.8000000000000003], supports = [[1, 2], [1, 2]])
 (equilibrium_strategies = [[0.0, 0.33333333333333337, 0.6666666666666666], [0.33333333333333315, 0.6666666666666669]], expected_payoffs = [4.000000000000001, 2.6666666666666665], supports = [[2, 3], [1, 2]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L762-L793">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.nash_se2-Tuple{Any}" href="#StrategicGames.nash_se2-Tuple{Any}"><code>StrategicGames.nash_se2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nash_se2(payoff; allow_mixed=true, max_samples=1, verbosity=STD)</code></pre><p>ONLY FOR BENCHMARKS, UNEXPORTED Solves Nash eqs using support enumeration for 2 players game using strictly the approach of <a href="https://doi.org/10.1016/j.geb.2006.03.015">Porter-Nudelman-Shoham (2008)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L697-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StrategicGames.unstack_payoff-Tuple{AbstractMatrix}" href="#StrategicGames.unstack_payoff-Tuple{AbstractMatrix}"><code>StrategicGames.unstack_payoff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unstack_payoff(x::AbstractMatrix)</code></pre><p>Unstack a payoff encoded in <em>long</em> format, where the first half of the columns are the action positions for each player and the second half of the columns are the payoff for the various players, to the Nplayers+1 dimensional array used in the library.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; # 2 players with 2 and 3 actions respectively
       long_payoff = [
            1 1 0.1 0.3;
            1 2 4 6;
            1 3 4 2;
            2 2 4 5;
            2 1 0.1 0.3;
            2 3 1.3 2;];
julia&gt; unstack_payoff(long_payoff)
2×3×2 Array{Float64, 3}:
[:, :, 1] =
 0.1  4.0  4.0
 0.1  4.0  1.3
[:, :, 2] =
 0.3  6.0  2.0
 0.3  5.0  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/StrategicGames.jl/blob/fb98fcd6c0bc74165eaf7d4d60b80e0d3336de1c/src/StrategicGames.jl#L69-L93">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="using_other_languages.html">« Using Python or R</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 14 April 2023 16:43">Friday 14 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
