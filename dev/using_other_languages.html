<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using Python or R · StrategicGames Documentation</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-DC4KL97F1C"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DC4KL97F1C', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">StrategicGames Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Index</a></li><li class="is-active"><a class="tocitem" href="using_other_languages.html">Using Python or R</a><ul class="internal"><li><a class="tocitem" href="#Use-StrategicGames-in-Python"><span>Use StrategicGames in Python</span></a></li><li><a class="tocitem" href="#Use-StrategicGames-in-R"><span>Use StrategicGames in R</span></a></li></ul></li><li><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="using_other_languages.html">Using Python or R</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="using_other_languages.html">Using Python or R</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/StrategicGames.jl/blob/main/docs/src/using_other_languages.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="using_other_languages"><a class="docs-heading-anchor" href="#using_other_languages">Using StrategicGames.jl from other programming languages</a><a id="using_other_languages-1"></a><a class="docs-heading-anchor-permalink" href="#using_other_languages" title="Permalink"></a></h1><p>In this section we provide two examples of using <code>StrategicGames</code> directly in Python or R (with automatic object conversion). Click <code>Details</code> for a more extended explanation of these examples. While I have no experience, the same approach can be used to access <code>StrategicGames</code> from any language with a binding to Julia, like Matlab or Javascript. </p><h2 id="Use-StrategicGames-in-Python"><a class="docs-heading-anchor" href="#Use-StrategicGames-in-Python">Use StrategicGames in Python</a><a id="Use-StrategicGames-in-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Use-StrategicGames-in-Python" title="Permalink"></a></h2><pre><code class="nohighlight hljs">$ python3 -m pip install --user juliacall</code></pre><pre><code class="language-python hljs">&gt;&gt;&gt; from juliacall import Main as jl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; jl.seval(&#39;using Pkg; Pkg.add(&quot;StrategicGames&quot;)&#39;) # Only once 
&gt;&gt;&gt; jl.seval(&quot;using StrategicGames&quot;)
&gt;&gt;&gt; sg     = jl.StrategicGames
&gt;&gt;&gt; payoff = np.array([[[-1,-1],[-3,0]],[[0,-3],[-2,-2]]]) # prisoner&#39;s dilemma
&gt;&gt;&gt; eq     = sg.nash_cp(payoff)
&gt;&gt;&gt; eq._jl_display() # force a &quot;Julian&quot; way of displaying of Julia objects
(status = MathOptInterface.LOCALLY_SOLVED, equilibrium_strategies = [[0.0, 0.9999999887780999], [0.0, 0.9999999887780999]], expected_payoffs = [-1.9999999807790678, -1.9999999807790678])
&gt;&gt;&gt; sg.is_nash(payoff,eq.equilibrium_strategies)
True
&gt;&gt;&gt; sg.dominated_strategies(payoff)
&lt;jl [[1], [1]]&gt;</code></pre><details><summary>Details</summary><p>We show for Python two separate &quot;Julia from Python&quot; interfaces, <a href="https://github.com/JuliaPy/pyjulia">PyJulia</a> and <a href="https://github.com/cjdoris/PythonCall.jl">JuliaCall</a> with the second one being the most recent one.</p><h4 id="With-the-classical-pyjulia-package"><a class="docs-heading-anchor" href="#With-the-classical-pyjulia-package">With the classical <code>pyjulia</code> package</a><a id="With-the-classical-pyjulia-package-1"></a><a class="docs-heading-anchor-permalink" href="#With-the-classical-pyjulia-package" title="Permalink"></a></h4><p><a href="https://github.com/JuliaPy/pyjulia">PyJulia</a> is a relativelly old method to use Julia code and libraries in Python. It works great but it requires that you already have a Julia working installation on your PC, so we need first to download and install the Julia binaries for our operating system from <a href="https://julialang.org/">JuliaLang.org</a>. Be sure that Julia is working by opening the Julia terminal and e.g. typing <code>println(&quot;hello world&quot;)</code></p><p>Install <code>PyJulia</code> with: </p><pre><code class="nohighlight hljs">$ python3 -m pip install --user julia   # the name of the package in `pip` is `julia`, not `PyJulia`</code></pre><p>We can now open a Python terminal and, to obtain an interface to Julia, just run:</p><pre><code class="language-python hljs">&gt;&gt;&gt; import julia
&gt;&gt;&gt; julia.install() # Only once to set-up in julia the julia packages required by PyJulia
&gt;&gt;&gt; jl = julia.Julia(compiled_modules=False)</code></pre><p>If we have multiple Julia versions, we can specify the one to use in Python passing <code>julia=&quot;/path/to/julia/binary/executable&quot;</code> (e.g. <code>julia = &quot;/home/myUser/lib/julia-1.8.0/bin/julia&quot;</code>) to the <code>install()</code> function.</p><p>The <code>compiled_module=False</code> in the Julia constructor is a workaround to the common situation when the Python interpreter is statically linked to <code>libpython</code>, but it will slow down the interactive experience, as it will disable Julia packages pre-compilation, and every time we will use a module for the first time, this will need to be compiled first. Other, more efficient but also more complicate, workarounds are given in the package documentation, under the https://pyjulia.readthedocs.io/en/stable/troubleshooting.html[Troubleshooting section].</p><p>Let&#39;s now add to Julia the StrategicGames package. We can surely do it from within Julia, but we can also do it while remaining in Python:</p><pre><code class="language-python hljs">&gt;&gt;&gt; jl.eval(&#39;using Pkg; Pkg.add(&quot;StrategicGames&quot;)&#39;) # Only once to install StrategicGames</code></pre><p>While <code>jl.eval(&#39;some Julia code&#39;)</code> evaluates any arbitrary Julia code (see below), most of the time we can use Julia in a more direct way. Let&#39;s start by importing the StrategicGames Julia package as a submodule of the Python Julia module:</p><pre><code class="language-python hljs">&gt;&gt;&gt; from julia import StrategicGames
&gt;&gt;&gt; jl.seval(&quot;using StrategicGames&quot;)</code></pre><p>As you can see, it is no different than importing any other Python module.</p><p>For the data, let&#39;s load the payoff matrix &quot;Python side&quot; using Numpy:</p><pre><code class="language-python hljs">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; payoff = np.array([[[-1,-1],[-3,0]],[[0,-3],[-2,-2]]]) # prisoner&#39;s dilemma</code></pre><p>We can now call StrategicGames functions as we would do for any other Python library functions. In particular, we can pass to the functions (and retrieve) complex data types without worrying too much about the conversion between Python and Julia types, as these are converted automatically:</p><pre><code class="language-python hljs">&gt;&gt;&gt; eq = StrategicGames.nash_cp(payoff)
&gt;&gt;&gt; # Note that array indexing in Julia start at 1
&gt;&gt;&gt; eq
&lt;PyCall.jlwrap (status = MathOptInterface.LOCALLY_SOLVED, equilibrium_strategies = [[0.0, 0.9999999887780999], [0.0, 0.9999999887780999]], expected_payoffs = [-1.9999999807790678, -1.9999999807790678])
&gt;&gt;&gt; StrategicGames.is_nash(payoff,eq.equilibrium_strategies)
True
&gt;&gt;&gt; StrategicGames.dominated_strategies(payoff)
[array([1], dtype=int64), array([1], dtype=int64)]</code></pre><p>Note: If we are using the <code>jl.eval()</code> interface, the objects we use must be already known to julia. To pass objects from Python to Julia, import the julia <code>Main</code> module (the root module in julia) and assign the needed variables, e.g.</p><pre><code class="language-python hljs">&gt;&gt;&gt; X_python = [1,2,3,2,4]
&gt;&gt;&gt; from julia import Main
&gt;&gt;&gt; Main.X_julia = X_python
&gt;&gt;&gt; jl.eval(&#39;sum(X_julia)&#39;)
12</code></pre><p>Another alternative is to &quot;eval&quot; only the function name and pass the (python) objects in the function call:</p><pre><code class="language-python hljs">&gt;&gt;&gt; jl.eval(&#39;sum&#39;)(X_python)
12</code></pre><h4 id="With-the-newer-JuliaCall-python-package"><a class="docs-heading-anchor" href="#With-the-newer-JuliaCall-python-package">With the newer <code>JuliaCall</code> python package</a><a id="With-the-newer-JuliaCall-python-package-1"></a><a class="docs-heading-anchor-permalink" href="#With-the-newer-JuliaCall-python-package" title="Permalink"></a></h4><p><a href="https://github.com/cjdoris/PythonCall.jl">JuliaCall</a> is a newer way to use Julia in Python that doesn&#39;t require separate installation of Julia.</p><p>Istall it in Python using <code>pip</code> as well:</p><pre><code class="nohighlight hljs">$ python3 -m pip install --user juliacall</code></pre><p>We can now open a Python terminal and, to obtain an interface to Julia, just run:</p><pre><code class="language-python hljs">&gt;&gt;&gt; from juliacall import Main as jl</code></pre><p>If you have <code>julia</code> on PATH, it will use that version, otherwise it will automatically download and install a private version for <code>JuliaCall</code></p><p>If we have multiple Julia versions, we can specify the one to use in Python passing <code>julia=&quot;/path/to/julia/binary/executable&quot;</code> (e.g. <code>julia = &quot;/home/myUser/lib/julia-1.8.0/bin/julia&quot;</code>) to the <code>install()</code> function.</p><p>To add <code>StrategicGames</code> to the JuliaCall private version we evaluate the julia package manager <code>add</code> function:</p><pre><code class="language-python hljs">&gt;&gt;&gt; jl.seval(&#39;using Pkg; Pkg.add(&quot;StrategicGames&quot;)&#39;) # Only once to install StrategicGames</code></pre><p>As with <code>PyJulia</code> we can evaluate arbitrary Julia code either using <code>jl.seval(&#39;some Julia code&#39;)</code> and by direct call, but let&#39;s first import <code>StrategicGames</code>:</p><pre><code class="language-python hljs">&gt;&gt;&gt; jl.seval(&quot;using StrategicGames&quot;)
&gt;&gt;&gt; sg = jl.StrategicGames</code></pre><p>For the data, we reuse the <code>payoff</code> Numpy arrays we created earlier.</p><p>We can now call StrategicGames functions as we would do for any other Python library functions. In particular, we can pass to the functions (and retrieve) complex data types without worrying too much about the conversion between Python and Julia types, as these are converted automatically:</p><pre><code class="language-python hljs">&gt;&gt;&gt; eq = sg.nash_cp(payoff)
&gt;&gt;&gt; eq._jl_display() # force a &quot;Julian&quot; way of displaying of Julia objects
(status = MathOptInterface.LOCALLY_SOLVED, equilibrium_strategies = [[0.0, 0.9999999887780999], [0.0, 0.9999999887780999]], expected_payoffs = [-1.9999999807790678, -1.9999999807790678])
&gt;&gt;&gt; sg.is_nash(payoff,eq.equilibrium_strategies)
True
&gt;&gt;&gt; sg.dominated_strategies(payoff)
&lt;jl [[1], [1]]&gt;
</code></pre><p>Note: If we are using the <code>jl.eval()</code> interface, the objects we use must be already known to julia. To pass objects from Python to Julia, we can write a small Julia <em>macro</em>:</p><pre><code class="language-python hljs">&gt;&gt;&gt; X_python = [1,2,3,2,4]
&gt;&gt;&gt; jlstore = jl.seval(&quot;(k, v) -&gt; (@eval $(Symbol(k)) = $v; return)&quot;)
&gt;&gt;&gt; jlstore(&quot;X_julia&quot;,X_python)
&gt;&gt;&gt; jl.seval(&quot;sum(X_julia)&quot;)
12</code></pre><p>Another alternative is to &quot;eval&quot; only the function name and pass the (python) objects in the function call:</p><pre><code class="language-python hljs">&gt;&gt;&gt; X_python = [1,2,3,2,4]
&gt;&gt;&gt; jl.seval(&#39;sum&#39;)(X_python)
12</code></pre><h4 id="Conclusions-about-using-StrategicGames-in-Python"><a class="docs-heading-anchor" href="#Conclusions-about-using-StrategicGames-in-Python">Conclusions about using StrategicGames in Python</a><a id="Conclusions-about-using-StrategicGames-in-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusions-about-using-StrategicGames-in-Python" title="Permalink"></a></h4><p>Using either the direct call or the <code>eval</code> function, wheter in <code>Pyjulia</code> or <code>JuliaCall</code>, we should be able to use all the StrategicGames functionalities directly from Python. If you run into problems using StrategicGames from Python, <a href="https://github.com/sylvaticus/StrategicGames.jl/issues/new">open an issue</a> specifying your set-up.</p></details><h2 id="Use-StrategicGames-in-R"><a class="docs-heading-anchor" href="#Use-StrategicGames-in-R">Use StrategicGames in R</a><a id="Use-StrategicGames-in-R-1"></a><a class="docs-heading-anchor-permalink" href="#Use-StrategicGames-in-R" title="Permalink"></a></h2><pre><code class="language- hljs">&gt; install.packages(&quot;JuliaCall&quot;) # only once
&gt; library(JuliaCall)
&gt; julia_setup(installJulia = TRUE) # use installJulia = TRUE to let R download and install a private copy of julia, FALSE to use an existing Julia local installation
&gt; julia_eval(&#39;using Pkg; Pkg.add(&quot;StrategicGames&quot;)&#39;) # only once
&gt; julia_eval(&quot;using StrategicGames&quot;)
&gt; payoff = array(c(-1,0,-3,-2,-1,-3,0,-2), dim=c(2,2,2)) # rows: players 1, cols: players 2, 3rd dim: players
&gt; eq     = julia_call(&quot;nash_cp&quot;,payoff)
&gt; eq
Julia Object of type NamedTuple{(:status, :equilibrium_strategies, :expected_payoffs), Tuple{MathOptInterface.TerminationStatusCode, Vector{Vector{Float64}}, Vector{Float64}}}.
(status = MathOptInterface.LOCALLY_SOLVED, equilibrium_strategies = [[0.0, 0.9999999887780999], [0.0, 0.9999999887780999]], expected_payoffs = [-1.9999999807790678, -1.9999999807790678])
&gt; equilibrium_strategies = field(eq,&quot;equilibrium_strategies&quot;)
&gt; strategy_player1       = julia_call(&quot;getindex&quot;,equilibrium_strategies,as.integer(1))
&gt; strategy_player1
[1] 0 1
&gt; julia_call(&quot;is_nash&quot;,payoff,equilibrium_strategies)
[1] TRUE
&gt; julia_call(&quot;dominated_strategies&quot;,payoff)
Julia Object of type Vector{Vector{Int64}}.
[[1], [1]]</code></pre><details><summary>Details</summary><p>For R we show how to access <code>StrategicGames</code> functionalities using the <a href="https://github.com/Non-Contradiction/JuliaCall">JuliaCall</a> R package (no relations with the homonymous Python package).</p><p>Let&#39;s start by installing <a href="https://cran.r-project.org/web/packages/JuliaCall/index.html"><code>JuliaCall</code></a> in R:</p><pre><code class="language- hljs">&gt; install.packages(&quot;JuliaCall&quot;)
&gt; library(JuliaCall)
&gt; julia_setup(installJulia = TRUE) # use installJulia = TRUE to let R download and install a private copy of julia, FALSE to use an existing Julia local installation</code></pre><p>Note that, differently than <code>PyJulia</code>, the &quot;setup&quot; function needs to be called every time we start a new R section, not just when we install the <code>JuliaCall</code> package. If we don&#39;t have <code>julia</code> in the path of our system, or if we have multiple versions and we want to specify the one to work with, we can pass the <code>JULIA_HOME = &quot;/path/to/julia/binary/executable/directory&quot;</code> (e.g. <code>JULIA_HOME = &quot;/home/myUser/lib/julia-1.1.0/bin&quot;</code>) parameter to the <code>julia_setup</code> call. Or just let <code>JuliaCall</code> automatically download and install a private copy of julia.</p><p><code>JuliaCall</code> depends for some things (like object conversion between Julia and R) from the Julia <code>RCall</code> package. If we don&#39;t already have it installed in Julia, it will try to install it automatically.</p><p>As in Python, let&#39;s start from creating the payoff array in R and do some work with it in Julia:</p><pre><code class="language- hljs">&gt; payoff = array(c(-1,0,-3,-2,-1,-3,0,-2), dim=c(2,2,2)) # rows: players 1, cols: players 2, 3rd dim: players</code></pre><p>Let&#39;s install StrategicGames. As we did in Python, we can install a Julia package from Julia itself or from within R:</p><pre><code class="language- hljs">&gt; julia_eval(&#39;using Pkg; Pkg.add(&quot;StrategicGames&quot;)&#39;)</code></pre><p>We can now &quot;import&quot; the StrategicGames julia package (in julia a &quot;Package&quot; is basically a module plus some metadata that facilitate its discovery and integration with other packages) and call its functions with the <code>julia_call(&quot;juliaFunction&quot;,args)</code> R function:</p><pre><code class="language- hljs">&gt; julia_eval(&quot;using StrategicGames&quot;)
&gt; eq = julia_call(&quot;nash_cp&quot;,payoff)
&gt; eq
Julia Object of type NamedTuple{(:status, :equilibrium_strategies, :expected_payoffs), Tuple{MathOptInterface.TerminationStatusCode, Vector{Vector{Float64}}, Vector{Float64}}}.
(status = MathOptInterface.LOCALLY_SOLVED, equilibrium_strategies = [[0.0, 0.9999999887780999], [0.0, 0.9999999887780999]], expected_payoffs = [-1.9999999807790678, -1.9999999807790678])
&gt; equilibrium_strategies = field(eq,&quot;equilibrium_strategies&quot;)
&gt; strategy_player1       = julia_call(&quot;getindex&quot;,equilibrium_strategies,as.integer(1))
&gt; strategy_player1
[1] 0 1
&gt; julia_call(&quot;is_nash&quot;,payoff,equilibrium_strategies)
[1] TRUE
&gt; julia_call(&quot;dominated_strategies&quot;,payoff)
Julia Object of type Vector{Vector{Int64}}.
[[1], [1]]</code></pre><p>As alternative, we can embed Julia code directly in R using the <code>julia_eval()</code> function:</p><pre><code class="language- hljs">get_eq_strategies &lt;- julia_eval(&#39;
  function get_strategy(payoff,n)
    eq = nash_cp(payoff)
    return eq.equilibrium_strategies[Int(n)]
  end
&#39;)</code></pre><p>We can then call the above function in R in one of the following three ways:</p><ol><li><code>get_eq_strategies(payoff,2)</code></li><li><code>julia_assign(&quot;payoff_julia_obj&quot;,payoff); julia_eval(&quot;get_strategy(payoff_julia_obj,2)&quot;)</code></li><li><code>julia_call(&quot;get_strategy&quot;,payoff,2)</code></li></ol><p>While other &quot;convenience&quot; functions are provided by the package, using  <code>julia_call</code>, or <code>julia_assign</code> followed by <code>julia_eval</code>, should suffix to use <code>StrategicGames</code> from R. If you run into problems using StrategicGames from R, <a href="https://github.com/sylvaticus/StrategicGames.jl/issues/new">open an issue</a> specifying your set-up.</p></details></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Index</a><a class="docs-footer-nextpage" href="api.html">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 19 April 2023 14:56">Wednesday 19 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
